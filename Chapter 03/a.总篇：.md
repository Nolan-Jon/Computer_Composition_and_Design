### 一、思维导图：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/计算机的算术运算思维导图.jpg)
### 二、编码：
#### 1.有符号数：
- 我们默认后面的示例在位宽为8的数据位中进行讨论。
- 有符号数指的就是分正负号的数据。
- 在计算机的发展史中，一共使用过三种类型的编码来表示有符号数：原码——反码——补码，最终在19世纪60年代左右补码成为了有符号数的历史选择。
##### a.原码：
- 我们把最高位当做符号位，剩下的七位用作数据位。
- 如果符号位为0，那么数据表示正数，如果符号位为1，数据表示负数。
- 表示范围：
	- 正数：0000 0000 ~ 0111 1111(0 ~ 127)
	- 负数：1111 1111 ~ 1000 0000(-127 ~ -0)
- 很显然，我们发现使用原码来表示的话会有两个0，一个是+0，一个是-0，由于0的不唯一性，我们抛弃了原码。
##### b.反码：
- 同样，我们把最高位当做符号位，剩下的七位表示数据位，当符号位为0的时候表示正数，为1的时候表示负数。
- 和原码的区别：
	- 在负数的表示上有区别，对于负数，我们首先要知道这个负数的相反数的编码，也就是对应的正数的编码，然后每一位全部取反(包括符号位在内，因为取反之后符号位正好从0变为1)。
- 表示范围：
	- 正数：0000 0000 ~ 0111 1111(0 ~ 127)
	- 负数：1000 0000 ~ 1111 1111(-127 ~ -0)
- 很显然，用反码来表示和用补码来表示的问题一样，都会有0不唯一这一个问题，因此我们抛弃了反码。
##### c.补码：
- 既然上面两种编码都有0不唯一的问题，那么我们是不是可以考虑把负数表示的范围更改一下，从-127 ~ -0更改为-128 ~ -1，这样不就可以解决0不唯一的问题了吗。
###### 从原码入手：
- 我们首先考虑从原码入手，把1111 1111 ~ 1000 0000映射为：-128 ~ -1，我们现在这样看着好像很合理，但实际上我们做一个运算：-1 + 127 = 1000 0000 + 0111 1111 = 1111 1111，正常结果应该是126，但运算结果确实-127，因此这种方法我们抛弃。
###### 从反码入手：
- 我们再考虑从反码入手，把1000 0000 ~ 1111 1111映射为：-128 ~ -1，现在我们进行运算，127 + (-1) = 0111 1111 + 1111 1111 = 1 0111 1110 由于只有8位，因此最高位是要被截掉的，因此结果为：0111 1110，表示126，其他运算结果也都合理。
- 这样我们就得到了补码。
###### 补码：
- 通过上面的分析我们知道，补码与其他两种编码的区别在于只有负数的表示不同。
- 补码的负数表示：
	- 首先我们要知道这个负数的相反数的补码(该补码与原码和反码相同)，我们把这个原码取反之后在加1，就表示出了这个负数的补码。
- 表示范围：
	- 正数：0000 0000 ~ 0111 1111(0 ~ 127)
	- 负数：1000 0000 ~ 1111 1111(-128 ~ -1)
###### 补码的相反数准则：
- 我们可以发现，对于互为相反数的一组数，他们的补码相加同样为0(有一些是得到九位数1 0000 0000，但硬件位是固定的，因此相当于0000 0000)。
- 因此，我们可以认为，二进制补码的相反数就是其取反再加1。
###### 补码使用的优点：
- 使用补码，我们可以把减法直接当成加法来操作，这样就省去了构建减法器的工作。
#### 2.无符号数：
- 无符号数是非负数，因此我们在表示无符号数的时候，不需要符号位，直接使用其二进制编码对无符号数进行编码即可。
- 八位的无符号数表示范围：
	- 0000 0000 ~ 1111 1111(0 ~ 255)
#### 3.溢出：
- 溢出有两种情况：
	- 赋值溢出，把16位数据赋值到一个8位字段中。
	- 运算溢出，对于运算溢出，我们只考虑有符号数的运算溢出，无符号数经常用来表示内存地址，因此无符号数的溢出可以被忽略。
- 四种加减运算的溢出：
	- 溢出产生的原因：用来表示数据的位数有限，而不像我们的现实生活中的数据可以无穷大。
	- 两个正数相加结果为负数，此时发生溢出。
	- 两个负数相加结果为正数，此时发生溢出。
	- 上面上面这两种叫做上溢，也就是在相加的过程中，占用了符号位。

	- 一个正数减去一个负数的结果为负，此时发生溢出。
	- 一个负数减去一个正数的结果为正，此时发生溢出。
	- 上面这两种情况叫做下溢，也就是在做减法的过程中，不够减，借用符号位造成了溢出。
##### 对溢出进行处理：
- 操作有符号数的时候，如果在运算的时候发生了溢出，我们要对溢出做出处理。
- add，addi，sub这三条指令是对有符号数进行运算的，如果发生溢出，这三条指令会产生异常。
##### 异常：
- 异常也叫中断，异常是打断处理器正常进程的系统调用，注意异常是操作系统的行为。
- 产生溢出的这条指令地址会保存在一个名为EPC的寄存器中(EPC是异常程序计数器，不是通用寄存器)，然后计算机会跳转到一个预先设置好的地址去执行相应的异常处理程序，执行完之后返回到原来的程序中继续执行(通过寄存器跳转指令跳转到原程序中，但是由于EPC不是通用寄存器，因此我们需要使用一个名为mfc0的指令将EPC中的地址传到通用寄存器中)。
### 三、乘法运算：
<<<<<<< HEAD
##### 1.二进制基础乘法器：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/乘法器(1)_页面_1.jpg)![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/乘法器(1)_页面_2.jpg)
##### 2.改进版的二进制乘法器：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/乘法器(1)_页面_3.jpg)![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/2134DF73B71B9334D2C1E924AF94AF19.png)
### 四、除法运算：
##### 1.二进制基础除法器：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/除法器_页面_1.jpg)![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/21CB342EBE552A18A94687CD49F24F39.png)![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/除法器_页面_3.jpg)
##### 2.二进制改进除法器：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/除法器_页面_4.jpg)![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/B8D86313D8EB7E713C1666E70EB60E8B.png)
### 五、浮点数：
##### 1.计算机中浮点数的表示形式：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/浮点数_页面_1.jpg)
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/浮点数_页面_2.jpg)
##### 2.浮点数的运算规则：
###### a.加法运算：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/浮点数_页面_3.jpg)
###### b.乘法运算：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/浮点数_页面_4.jpg)
###### c.浮点数的舍入问题：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/32503E2AF05B6AAF1035F7C23D17EAC7.png)
##### 3.浮点数的操作指令：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/浮点数_页面_6.jpg)
### 六、有符号数和无符号数乘、除运算：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/Page1(4).jpg)![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/8CF8F27B417062EA8C90CC2D267FC119.png)
### 七、MIPS-32基本常用指令：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/AF305B78CFAB8B469AB19FB49C7FCF2D.png)


=======
##### 1.二进制的乘法运算：
- 二进制的乘法运算和十进制的乘法运算相同，都能够采用列竖式的方式进行。
- 二进制的乘法运算更为简单，原因是只有1 x 1，1 x 0，0 x 0这三种情况。
- 下面将使用列竖式乘法的方式计算二进制：1000 x 1001
```
	 1000
	x
	 1001
	——————
	 1000
	0000
   0000
  1000
  ————————
  1001000	 
```
- 观察上面这个二进制的乘法运算：
	- 我们定义被乘数是1000，乘数是1001。
	- 我们可以从上面这个二进制乘法运算中发现一些算法从而将乘法运算转换成加法运算。
	- 乘数每次向右移动一位，并且我们只需要乘数的最右一位。被乘数每次向左移动一位。
		- 1.首先，乘数的最右一位是1，把被乘数放到一个寄存器a中。
		- 2.其次，右移乘数，左移被乘数。
		- 3.此时乘数最右一位为0，因此继续右移乘数，左移被乘数。
		- 4.此时乘数的最右一位依旧为0，因此继续右移乘数，左移被乘数。
		- 5.此时乘数的最后一位是1，把此时的被乘数加到寄存器a中。
		- 6.此时寄存器a中的结果就是二进制乘法运算的结果。
##### 2.根据上面的二进制乘法算法设置我们的乘法器：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/Page1(1)_页面_1.jpg)

![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/Page1(1)_页面_2.jpg)

![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/Page1(1)_页面_3.jpg)

![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/Page1(1)_页面_4.jpg)

![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/Page1(1)_页面_5.jpg)
>>>>>>> d248944 (The third commit and Chapter 03)
